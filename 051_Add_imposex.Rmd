---
title: "051_Add_imposex"
author: "DHJ"
date: "2024-09-06"
output: 
  html_document:
    keep_md: true
    toc: true  
    toc_float: true
params:
  oracleuser: 
    label: "NIVA initials (3 capital letters)"
    value: "DHJ"
    input: text
  oraclepass: 
    label: "Oracle password"
    value: ""
    input: password
---


*NOTE: To be able to do this, you need write access to Nivabasen and SQL Developer (or something similar).*
The way this script works, is that it is used to create SQL for inserting rows into Nivabasen, 
which then are copy-pasted into SQL Developer.  

* Imposex and intersex files were copied from Project Portal (210200 - Miljøgifter i kystområdene 2021-2025):  
    - 2023 / Opparbeiding / Snegler  
    - saved to Input_data/opparbeiding_biota/Snegl_2023  
    

## 1. Libraries and functions
```{r}
#| results: false
#| warnings: false        
#|

# For loading libraries without startup messages
library2 <- function(...) suppressPackageStartupMessages(library(...))

library2(dplyr)
library2(dbplyr)
library2(purrr)
library2(lubridate)
library2(stringr)
library2(tidyr)
library2(ggplot2)
# library(safejoin)   # https://github.com/moodymudskipper/safejoin
library2(readxl)

source("002_Utility_functions.R")

lookup_methods <- data.frame(
  NAME = c("ALAD", "EROD", "PROTV", "AY380"),
  METHOD_ID = c(28580, 28575, 28579, 28574)   
)  

```


## 2. Settings  
```{r}

measurement_year <- 2023

# 'write_sql_files' shall normally be TRUE  
# can sometimes be useufle that it is FALSE (to avoid overwriting files that were OK already)
write_sql_files <- TRUE

```


## 3. Set up Oracle connection   

- This part of the script will ask you about your user name and password to Nivabasen  

```{r}

# if the script is run interactively
if (interactive()){
  
  con <- DBI::dbConnect(odbc::odbc(),
                      Driver = "/opt/conda/orahome/libsqora.so.12.1",
                      DBQ = "dbora-niva-prod01.niva.corp:1555/NIVABPRD",
                      UID = rstudioapi::askForPassword("Database username (NIVA initials, 3 capital letters)"),
                      PWD = rstudioapi::askForPassword("Nivabasen password")
  )
  
} else {
# if the script is knitted
  
  # If params$oraclepass is just an empty string, you have probably just clicked the Knit button  
  if (params$oraclepass == ""){
    stop("Password = ''. You must use 'Knit with Parameters...' from the menu (pull-down menu from the Knit button), and enter you password in the dialog")
  }
  
  con <- DBI::dbConnect(odbc::odbc(),
                        Driver = "/opt/conda/orahome/libsqora.so.12.1",
                        DBQ = "dbora-niva-prod01.niva.corp:1555/NIVABPRD",
                        UID = params$oracleuser,
                        PWD = params$oraclepass
  )
  
}

test_connection <- DBI::dbGetQuery(con, "select * from NIVADATABASE.PROJECTS where rownum < 4")
if ("test_connection" %in% ls()){
  if (nrow(test_connection) == 3)
    cat("Connection to Nivadatabase set up and tested")
}

rm(test_connection)

```

### Get pointers to Nivabase tables  

* Note that when dbplyr joins tables, it will try to join using all fields (columns) that have the same name in the two tables  
    - therefore, fields with the same column names but that cannot be used for joining (such as ENTERED_BY, ENTERED_DATE) must either be removed or renamed   
    - if not, no rows will be joined (probably)  
* Columns that are actually used for joins should of couse not be removed (e.g., STATION_ID, SAMPLE_ID)   

```{r}

# Remove ENTERED_BY and ENTERED_DATE from all tables because they mess up the joins

methods <- tbl(con, in_schema("NIVADATABASE", "METHOD_DEFINITIONS")) %>%
  select(METHOD_ID, NAME, UNIT, LABORATORY, METHOD_REF, MATRIX_ID)
measurements <- tbl(con, in_schema("NIVADATABASE", "BIOTA_CHEMISTRY_VALUES")) %>%
  select(SAMPLE_ID, METHOD_ID, VALUE_ID, VALUE, FLAG1, 
         DETECTION_LIMIT, UNCERTAINTY, QUANTIFICATION_LIMIT)
# drop STATION_ID, TAXONOMY_CODE_ID from samples
samples <- tbl(con, in_schema("NIVADATABASE", "BIOTA_SAMPLES")) %>%
  select(STATION_ID, SAMPLE_ID, TISSUE_ID, SAMPLE_NO, REPNO, REMARK) %>%
  rename(REMARK_sample = REMARK)
samples_specimens <- tbl(con, in_schema("NIVADATABASE", "BIOTA_SAMPLES_SPECIMENS")) %>%
  select(SPECIMEN_ID, SAMPLE_ID)
specimens <- tbl(con, in_schema("NIVADATABASE", "BIOTA_SINGLE_SPECIMENS")) %>%
  select(STATION_ID, SPECIMEN_ID, SPECIMEN_NO, DATE_CAUGHT, TAXONOMY_CODE_ID, REMARK) %>%
  rename(REMARK_specimen = REMARK)
project_stations <- tbl(con, in_schema("NIVADATABASE", "PROJECTS_STATIONS")) %>%
  select(STATION_ID, STATION_CODE, STATION_NAME, PROJECT_ID )
projects <- tbl(con, in_schema("NIVADATABASE", "PROJECTS")) %>%
  select(PROJECT_ID, PROJECT_NAME, PROJECT_DESCRIPTION)

# Labware sample table  
labware_checksample <- tbl(con, in_schema("NIVADATABASE", "LABWARE_CHECK_SAMPLE")) %>%
  select(PROSJEKT, SAMPLED_DATE, DESCRIPTION, AQUAMONITOR_CODE, TISSUE, X_BULK_BIO)

# Lookup tables  
taxonomy_codes <- tbl(con, in_schema("NIVADATABASE", "TAXONOMY_CODES")) %>%
  select(TAXONOMY_CODE_ID, CODE, NIVA_TAXON_ID)
taxonomy <- tbl(con, in_schema("NIVADATABASE", "TAXONOMY")) %>%
  select(NIVA_TAXON_ID, LATIN_NAME)
tissue <- tbl(con, in_schema("NIVADATABASE", "BIOTA_TISSUE_TYPES")) %>%
  select(TISSUE_ID, TISSUE_NAME)
lims_id <- tbl(con, in_schema("NIVADATABASE", "LABWARE_BSID")) %>%
  select(BIOTA_SAMPLE_ID, LABWARE_TEXT_ID)

# Not really necessary here:
# matrix <- tbl(con, in_schema("NIVADATABASE", "MATRIX_DEFINITIONS")) %>%
#   select(MATRIX_ID, MATRIX_NAME)
# collect(matrix)

```

## 4. Read data 

### Create data that shall be added to NIVAbase   

#### Imposex: file names and station codes  

```{r}

# folder_vdsi <- "K:/Prosjekter/Sjøvann/JAMP/2021/opparbeiding/Snegl"
folder_vdsi <- paste0("Input_data/opparbeiding_biota/Snegl_", measurement_year, "/")

# Get all file names
fn <- dir(folder_vdsi, pattern = ".xlsx")
# Remove some file names
fn <- fn[!grepl("imposex_mal", fn)]       # mal (template file)
fn <- fn[!grepl("intersex", fn)]          # skip intersex for now (dealt with further down)
fn <- fn[!grepl("~", fn, fixed = TRUE)]   # names with "~" are usually temporary files

# Set names of 'fn'
# Should be equal to station code 
# We find this by extracting all characters to the left of the first underscore  
names(fn) <- stringr::str_extract(fn, "[^_]+")

# Manual fix: 227G changed to 227G2
names(fn)[names(fn) == "227G"] <- "227G2"

# Check that the stations codes are correct:

message("Check station codes!")
fn
message("If not, you can correct like in the example given in the end of this code chunk")

# If not, you can correct like in the example below
# names(fn)[names(fn) == "131"] <- "131G"
# fn


```
#### Imposex: read files  

```{r}
# Function for reading one file (with file name 'fn')  
read_excel_imposex <- function(fn){
  df <- readxl::read_excel(paste0(folder_vdsi, "/", fn), skip = 6)
  df <- df[1:6]
  df <- df[!is.na(df$`Analysert av`),]
  df
}

dat_vdsi_list <- fn %>% map(read_excel_imposex)

# If there are errors, you may use 'safely', in that case the output is a list of lists 
#   and must be treated a bit differently. Run ?safely to read the documentation
# read_excel_imposex_s <- safely(read_excel_imposex)
# dat_vdsi_list <- fn %>% map(read_excel_imposex_s)

cat("\n\nData stored in 'dat_vdsi_list', a list of length", length(dat_vdsi_list))

```
#### Imposex: check number of rows - should be 50  
```{r}

#  unless oherwise noted in sheet (15G "Fant ikke flere snegl i år, men det er over 15 hunner.")
dat_vdsi_list %>% map_int(nrow)

```
#### Imposex: manually look at data, if needed  
```{r}

if (FALSE){
  dat_vdsi_list[["15G"]] %>% View()
  dat_vdsi_list[["36G"]] %>% View()
  
  # exampple of fixing:
  # dat_vdsi_list[["15G"]] <- dat_vdsi_list[["15G"]][1:50,]  # delete last line
}

```

#### Imposex: create data frame 'dat_vdsi'  

* combines list items to one data frame  
* pick only number, sex and Imposex  
* ...we will deal with length and penis length later  

```{r, message=FALSE}

dat_vdsi <- dat_vdsi_list %>% 
  map(~.[c(1,3,5)]) %>%
  bind_rows(.id = "STATION_CODE") %>%
  rename(VALUE_WW = VDSI, 
         Sex = `Kj<U+00F8>nn`) %>%
  mutate(PARAM = "VDSI",
         UNIT = "idx",
         LATIN_NAME = "Nucella lapillus",
         Sex = tolower(Sex))

# View(dat_vdsi)

cat("\n------------------------------------------\n")
cat("Imposex data: \n------------------------------------------\n")
xtabs(~is.na(VALUE_WW) + addNA(Sex), dat_vdsi)

```

#### Intersex: find files 

```{r}

# Get all file names
fn <- dir(folder_vdsi, pattern = ".xlsx")
fn <- fn[grepl("intersex", fn)]          # keep only intersex for now

names(fn) <- stringr::str_extract(fn, "[^_]+")

# Check that the stations codes are correct:
message("Check station codes!")
fn
message("If not, you can correct like in the example given in the end of this code chunk")


```

#### Intersex: read files  

```{r}

# function for reading one file
read_excel_intersex <- function(fn){
  df <- readxl::read_excel(paste0(folder_vdsi, fn), range = "A3:G53")
  df %>%
    filter(F == 1) %>%              # read only females
    mutate(STATION_CODE = "71G", 
           Sex = "f",
           PARAM = "Intersex",
           UNIT = "PERCENT",
           LATIN_NAME = "Littorina littorea") %>%
    mutate(VALUE_WW = `ISI   (intersex-stadie)`*100) %>%
    select(STATION_CODE, Sex, VALUE_WW, PARAM, LATIN_NAME)
}

dat_intersex_list <- fn %>% map(read_excel_intersex)

# If there are errors, you may use 'safely', in that case the output is a list of lists 
#   and must be treated a bit differently. Run ?safely to read the documentation
# read_excel_imposex_s <- safely(read_excel_imposex)
# dat_vdsi_list <- fn %>% map(read_excel_imposex_s)

cat("\n\nData stored in 'dat_intersex_list', a list of length", length(dat_intersex_list))

```
#### Intersex: check number of rows - should be reasonable    
```{r}

#  unless otherwise noted in sheet (15G "Fant ikke flere snegl i år, men det er over 15 hunner.")
dat_intersex_list %>% map_int(nrow)


```

#### Intersex: create data frame 'dat_intersex'  

* combines list items to one data frame  

```{r}

dat_intersex <- dat_intersex_list %>% 
  # map(~.[c(1,3,5)]) %>%
  bind_rows(.id = "STATION_CODE")

```


#### Combine imposex and intersex  

```{r}

# check names - not completely equal, but the important ones are  
# names(dat_vdsi)
# names(dat_intersex)

dat_1 <- bind_rows(dat_vdsi, dat_intersex) %>%
  filter(
    Sex == "f") %>%
  group_by(
    STATION_CODE, PARAM, LATIN_NAME) %>%
  summarise(
    VALUE = mean(VALUE_WW), .groups = "drop") %>%
  mutate(
    MYEAR = measurement_year,
    TISSUE_NAME = "Whole soft body"
  )

cat("\n------------------------------------------\n")
cat("Combined data: \n------------------------------------------\n")
xtabs(~PARAM, dat )

```

